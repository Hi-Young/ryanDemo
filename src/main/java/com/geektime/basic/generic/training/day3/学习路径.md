# Day 3 学习路径

按照以下顺序学习效果最佳 👇

---

## 第 1 步：理解问题 🤔

**运行并阅读：**
```
before/TypeBoundsProblemDemo.java
```

**你会看到：**
- ❌ 没有约束时，无法调用 T 的特定方法
- ❌ 为了支持不同类型，需要写重复代码
- ❌ 无法实现真正通用的方法

**思考：**
- 为什么 `<T>` 不能调用 `compareTo()`？
- 如何让编译器知道 T 有某些方法？

---

## 第 2 步：看看解决方案 💡

**运行并阅读：**
```
after/TypeBoundsSolutionDemo.java
```

**你会看到：**
- ✅ 用 `<T extends Comparable<T>>` 实现通用比较
- ✅ 用 `<T extends Number>` 实现通用求和
- ✅ 一个方法代替多个重复方法

**对比：**
- Before: 3 个重复方法
- After: 1 个通用方法

---

## 第 3 步：动手练习 ✍️

**打开文件：**
```
practice/TypeBoundsFillInBlanks.java
```

**你的任务：**
1. 阅读每个方法的需求和分析
2. 填写正确的类型约束（替换 `___填写类型约束___`）
3. 运行 `main()` 方法验证
4. 对照 `practice/answer/TypeBoundsFillInBlanksAnswer.java` 检查答案

**练习内容：**
- ⭐ 练习1-3：单一约束（Comparable、Number）
- ⭐⭐ 练习4-5：多重约束（& 连接多个接口）
- ⭐⭐⭐ 练习6：综合练习（约束 + 通配符）

**提示：**
- 先注释掉除了 test1_FindMax() 外的所有测试
- 完成练习1后，再打开 test2_Sum()
- 一步步来，不要着急！

---

## 第 4 步：理解泛型的限制 🚫

**运行并阅读：**
```
limits/TypeErasureLimitsDemo.java
```

**你会了解：**
- ❌ 不能 `new T()`
- ❌ 不能 `new T[]`
- ❌ 不能 `instanceof T`
- ❌ 静态方法不能用类的类型参数
- ✅ 如何用 `Class<T>` 绕过限制

**为什么有这些限制？**
- Java 泛型是"伪泛型"
- 编译后类型信息被擦除
- 运行时 `List<String>` 和 `List<Integer>` 是同一个类

---

## 学习检验 ✅

完成后，你应该能回答：

1. **什么时候需要类型约束？**
   - 当方法体内需要调用 T 的特定方法时

2. **如何写类型约束？**
   - 单一约束：`<T extends Comparable<T>>`
   - 多重约束：`<T extends Number & Comparable<T>>`

3. **类型擦除是什么？**
   - 泛型只在编译期存在，运行时被擦除
   - 所有 T 被替换成 Object 或其上界

4. **如何解决类型擦除的限制？**
   - 传入 `Class<T>` 对象
   - 使用 ArrayList 代替数组

---

## 常见问题 ❓

### Q1: `<T extends Comparable<T>>` 中两个 T 什么关系？
```java
<T extends Comparable<T>>
 ↑                      ↑
 |                      |
 类型参数               用于类型参数
```
意思是：T 必须实现 `Comparable<T>` 接口

### Q2: 为什么用 extends 而不是 implements？
因为 Java 用统一的 `extends` 关键字表示约束：
- 对类：`<T extends Animal>`
- 对接口：`<T extends Comparable<T>>`

### Q3: 多重约束的顺序重要吗？
- 如果有类，类必须第一个：`<T extends Animal & Serializable>`
- 接口之间顺序不重要：`<T extends A & B>` 和 `<T extends B & A>` 等价

### Q4: 什么时候用约束，什么时候用通配符？
- 约束（`<T extends X>`）：限制类型参数必须满足条件
- 通配符（`? extends X`）：增加参数类型的灵活性
- 可以组合使用！

---

**准备好了吗？开始第1步吧！** 🚀
