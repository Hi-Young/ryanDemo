# Day 5 学习路径

高级泛型技巧，深入理解自限定类型和 TypeToken 👇

---

## 第 1 步：理解问题 🤔

### 1.1 链式调用的类型丢失

**运行并阅读：**
```
before/ChainCallProblem.java
```

**你会看到：**
- ❌ Builder 模式继承时，链式调用断裂
- ❌ 父类方法返回 `this`，但类型是父类，不是子类
- ❌ 无法继续调用子类的方法

**思考：**
- 为什么 `setName()` 返回 `Builder` 而不是 `UserBuilder`？
- 如何让父类方法返回子类类型？

---

### 1.2 类型擦除的运行时问题

**运行并阅读：**
```
before/TypeErasureProblem.java
```

**你会看到：**
- ❌ 无法创建泛型数组 `new T[size]`
- ❌ 运行时无法区分 `List<String>` 和 `List<Integer>`
- ❌ JSON 反序列化无法知道元素类型

---

## 第 2 步：看解决方案 💡

### 2.1 自限定类型解决链式调用

**运行并阅读：**
```
after/SelfBoundedTypeDemo.java
```

**核心语法：**
```java
// 父类定义
class Builder<T extends Builder<T>> {
    public T setName(String name) {
        return (T) this;
    }
}

// 子类继承
class UserBuilder extends Builder<UserBuilder> {
    // 父类的 setName() 返回 UserBuilder！
}
```

**关键点：**
- 父类用 `<T extends Builder<T>>`（自限定）
- 子类继承时"传入自己"：`extends Builder<UserBuilder>`
- 父类方法返回 `T`（子类类型）

---

### 2.2 TypeToken 获取运行时类型

**运行并阅读：**
```
after/TypeTokenDemo.java
```

**核心原理：**
```java
// 使用时创建匿名内部类
TypeToken<List<String>> token = new TypeToken<List<String>>(){};
//                                                           ↑↑
//                                                    匿名内部类

// 通过反射获取泛型参数
Type type = token.getType();  // 可以得到 List<String>
```

**为什么可行：**
- 匿名内部类的泛型参数会保留在字节码中
- 通过反射读取父类的泛型参数
- 绕过类型擦除的限制

---

## 第 3 步：动手练习 ✍️

### 3.1 自限定类型填空

**打开文件：**
```
practice/SelfBoundedFillInBlanks.java
```

**练习内容：**
- ⭐ 练习1-2：Builder 模式和实体类
- ⭐⭐⭐ 练习3：Fluent API（Query DSL）

**填写内容：**
1. 父类的类型参数：`<T extends Builder<T>>`
2. 方法返回类型：`T`
3. 子类继承参数：`extends Builder<UserBuilder>`

**检查答案：**
```
practice/answer/SelfBoundedFillInBlanksAnswer.java
```

---

### 3.2 TypeToken 实现练习

**打开文件：**
```
practice/TypeTokenFillInBlanks.java
```

**练习内容：**
- ⭐⭐ 练习1：实现 TypeToken 的核心逻辑
- ⭐⭐ 练习2：处理复杂泛型类型
- ⭐⭐⭐ 练习3：模拟 Gson 的用法

**核心代码：**
```java
Type superclass = getClass().getGenericSuperclass();
ParameterizedType pt = (ParameterizedType) superclass;
this.type = pt.getActualTypeArguments()[0];
```

**检查答案：**
```
practice/answer/TypeTokenFillInBlanksAnswer.java
```

---

## 第 4 步：真实场景应用 🌟

**运行并阅读：**
```
advanced/RealWorldExamples.java
```

**你会学到：**
1. **Lombok @Builder** - 底层原理就是自限定类型
2. **JPA 实体类** - BaseEntity 的链式 setter
3. **MyBatis-Plus** - QueryWrapper 的流畅 API
4. **Java Enum** - `Enum<E extends Enum<E>>` 的奥秘

---

## 学习检验 ✅

完成后，你应该能回答：

### 关于自限定类型

1. **什么是自限定类型？**
   - 类型参数约束自己：`<T extends Base<T>>`
   - 让父类方法返回子类类型

2. **为什么子类要"传入自己"？**
   - `class Child extends Base<Child>`
   - 告诉编译器：T = Child
   - 父类方法返回的 T 就是 Child

3. **什么时候需要自限定类型？**
   - Builder 模式
   - 链式调用的实体类
   - Fluent API 设计

### 关于 TypeToken

1. **为什么 TypeToken 必须是抽象类？**
   - 强制使用者创建子类（匿名内部类）
   - 只有子类才能保留泛型参数信息

2. **为什么使用时要加 `{}`？**
   - `new TypeToken<String>(){}`
   - `{}` 创建了匿名内部类
   - 匿名类的泛型参数会保留在字节码中

3. **TypeToken 解决了什么问题？**
   - 绕过类型擦除
   - 在运行时获取泛型类型信息
   - 支持复杂的嵌套泛型（如 `List<User>`）

---

## 进阶思考 🧠

### 思考题1：Enum 的自限定类型

Java 枚举的定义是：
```java
public abstract class Enum<E extends Enum<E>>
```

**问题：**
- 为什么要用自限定类型？
- 如果不用，会有什么问题？

**提示：**
- 想想 `compareTo(E o)` 方法
- Color.RED.compareTo(Size.LARGE) 应该允许吗？

---

### 思考题2：TypeToken 的限制

**问题：**
- TypeToken 可以捕获 `List<T>` 的类型吗？（T 是类型参数）
- 为什么？

**提示：**
- `new TypeToken<List<T>>(){}` 中的 T 会被擦除吗？

---

### 思考题3：自限定类型的强制转换

**问题：**
- `return (T) this;` 这个强制转换安全吗？
- 会不会在运行时抛出 ClassCastException？

**提示：**
- 想想子类继承时传入的参数
- UserBuilder extends Builder<UserBuilder>，T = ?

---

## 常见问题 ❓

### Q1: 自限定类型太复杂，有更简单的方法吗？

**答：**
- 没有更简单的方法能达到同样的效果
- 一旦理解，就会发现它很自然
- Lombok、JPA 等主流框架都在用

### Q2: TypeToken 和 Class<T> 有什么区别？

**答：**
- `Class<T>` 只能表示简单类型：`String.class`
- `Class<T>` 无法表示泛型：无法写 `List<String>.class`
- `TypeToken` 可以表示复杂泛型：`new TypeToken<List<String>>(){}`

### Q3: 实际项目中真的会用到这些吗？

**答：**
- 自限定类型：非常常用（Lombok、JPA、MyBatis-Plus）
- TypeToken：框架开发常用（Gson、Guice）
- 业务代码可能不直接用，但理解原理很重要

---

## 推荐学习顺序

**第1天（重点）：**
1. 理解链式调用问题 → 20 分钟
2. 学习自限定类型 → 40 分钟
3. 完成练习1-2 → 30 分钟
4. 查看真实案例 → 20 分钟

**第2天（选学）：**
1. 理解类型擦除问题 → 20 分钟
2. 学习 TypeToken 原理 → 40 分钟
3. 完成 TypeToken 练习 → 40 分钟

---

**准备好挑战泛型的巅峰了吗？开始第1步吧！** 🚀
