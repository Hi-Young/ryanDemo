# 数据库死锁实战学习指南

## 📖 目录

1. [死锁基础理论](#1-死锁基础理论)
2. [项目结构说明](#2-项目结构说明)
3. [环境准备](#3-环境准备)
4. [死锁场景实战](#4-死锁场景实战)
5. [死锁监控和诊断](#5-死锁监控和诊断)
6. [死锁解决方案](#6-死锁解决方案)
7. [性能优化建议](#7-性能优化建议)
8. [常见问题解答](#8-常见问题解答)

---

## 1. 死锁基础理论

### 1.1 什么是数据库死锁

数据库死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种相互等待的现象。当存在外力介入时，这些事务都无法继续执行下去。

### 1.2 死锁产生的四个必要条件

1. **互斥条件**: 资源不能被多个事务同时使用
2. **持有和等待条件**: 事务持有至少一个资源，并等待获取其他事务持有的资源
3. **非剥夺条件**: 资源不能被强制从一个事务中抢夺
4. **循环等待条件**: 存在一个事务循环链，每个事务都在等待下一个事务所持有的资源

### 1.3 MySQL中的锁类型

#### 行级锁 (Row-level Locks)
- **Record Lock**: 记录锁，锁定索引记录
- **Gap Lock**: 间隙锁，锁定索引记录之间的间隙
- **Next-Key Lock**: Record Lock + Gap Lock

#### 事务隔离级别与锁的关系
- **READ UNCOMMITTED**: 最低级别，几乎不加锁
- **READ COMMITTED**: 只锁定正在读取的行
- **REPEATABLE READ**: MySQL默认级别，使用Gap Lock和Next-Key Lock
- **SERIALIZABLE**: 最高级别，锁定所有读取的行

---

## 2. 项目结构说明

```
src/main/java/com/ryan/deadlock/
├── entity/          # 实体类
│   ├── Account.java      # 账户实体
│   ├── Inventory.java    # 库存实体
│   └── OrderLock.java    # 订单实体
├── mapper/          # 数据访问层
│   ├── AccountMapper.java
│   ├── InventoryMapper.java
│   └── OrderLockMapper.java
├── service/         # 业务服务层
│   ├── TransferDeadlockService.java    # 转账死锁场景
│   ├── InventoryDeadlockService.java   # 库存死锁场景
│   └── IndexDeadlockService.java       # 索引死锁场景
├── monitor/         # 死锁监控
│   └── DeadlockMonitor.java
├── aspect/          # AOP切面
│   └── DeadlockMonitorAspect.java
└── controller/      # 控制器
    └── DeadlockTestController.java

src/main/resources/
└── sql/
    └── deadlock_tables.sql  # 数据库表结构
```

---

## 3. 环境准备

### 3.1 数据库初始化

1. **执行SQL脚本**
   ```bash
   mysql -u root -p < src/main/resources/sql/deadlock_tables.sql
   ```

2. **验证表创建**
   ```sql
   SHOW TABLES;
   -- 应该看到: account, inventory, order_locks
   ```

### 3.2 启动应用

```bash
# 方式1: Maven启动
mvn spring-boot:run

# 方式2: IDE启动
# 运行 com.RyanDemoApplication.main()
```

### 3.3 访问测试接口

- 主页信息: `GET http://localhost:18888/deadlock/`
- Swagger文档: `http://localhost:18888/swagger-ui.html` (如果配置了Swagger)

---

## 4. 死锁场景实战

### 4.1 转账死锁场景

#### 💰 业务场景
银行转账系统中，A向B转账的同时B向A转账，由于加锁顺序不同导致死锁。

#### 🔍 死锁原理
```
事务1: 锁定账户A → 等待锁定账户B
事务2: 锁定账户B → 等待锁定账户A
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **触发死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/transfer/simulate
   ```

2. **单独测试死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/transfer/deadlock-version?fromAccount=ACC001&toAccount=ACC002&amount=100.00"
   ```

3. **测试无死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/transfer/no-deadlock-version?fromAccount=ACC001&toAccount=ACC002&amount=100.00"
   ```

#### 📊 关键代码分析

**死锁版本 (TransferDeadlockService.transferWithDeadlock)**:
```java
// 问题: 按参数顺序加锁，容易产生死锁
Account fromAccount = accountMapper.selectByAccountNoForUpdate(fromAccountNo);
Account toAccount = accountMapper.selectByAccountNoForUpdate(toAccountNo);
```

**无死锁版本 (TransferDeadlockService.transferWithoutDeadlock)**:
```java
// 解决方案: 统一加锁顺序
String firstLockAccount = fromAccountNo.compareTo(toAccountNo) < 0 ? fromAccountNo : toAccountNo;
String secondLockAccount = fromAccountNo.compareTo(toAccountNo) < 0 ? toAccountNo : fromAccountNo;
```

### 4.2 库存扣减死锁场景

#### 📦 业务场景
电商系统中，多个订单同时扣减不同商品的库存，由于商品锁定顺序不同导致死锁。

#### 🔍 死锁原理
```
订单1: 锁定商品1001 → 等待锁定商品1002
订单2: 锁定商品1002 → 等待锁定商品1001
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **触发库存死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/inventory/simulate
   ```

2. **测试死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/inventory/reduce-deadlock-version?productIds=1001,1002&quantities=5,3"
   ```

3. **测试预留库存模式**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/inventory/reserve-confirm?productIds=1001,1002&quantities=2,1"
   ```

#### 📊 关键代码分析

**死锁版本**:
```java
// 问题: 按传入顺序逐个加锁
for (Integer productId : productIds) {
    Inventory inventory = inventoryMapper.selectByProductIdForUpdate(productId);
}
```

**无死锁版本**:
```java
// 解决方案: 按商品ID升序批量加锁
List<Inventory> inventories = inventoryMapper.selectByProductIdsForUpdate(productIds);
// SQL: SELECT * FROM inventory WHERE product_id IN (...) ORDER BY product_id FOR UPDATE
```

### 4.3 索引死锁场景

#### 📇 业务场景
Gap锁和Next-Key锁在并发范围查询和插入时产生的死锁。

#### 🔍 死锁原理

**Gap锁死锁**:
```
事务1: 范围查询产生Gap锁 → 尝试插入数据等待插入意向锁
事务2: 插入数据等待Gap锁 → 尝试范围查询等待Gap锁
结果:  相互等待，产生死锁
```

**Next-Key锁死锁**:
```
事务1: SELECT ... FOR UPDATE (用户1) → 等待用户2的锁
事务2: SELECT ... FOR UPDATE (用户2) → 等待用户1的锁
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **Gap锁死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/index/simulate-gap-lock
   ```

2. **Next-Key锁死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/index/simulate-next-key-lock
   ```

#### 📊 关键代码分析

**Gap锁产生场景**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ) // 关键: 可重复读级别
public void gapLockDeadlockScenario1() {
    // 范围查询产生Gap锁
    List<OrderLock> orders = orderLockMapper.selectOrdersByTimeRange(startTime, endTime);
    
    // 在Gap范围内插入，可能死锁
    orderLockMapper.insert(newOrder);
}
```

---

## 5. 死锁监控和诊断

### 5.1 实时死锁监控

#### 📊 监控接口
```bash
# 获取死锁统计
curl http://localhost:18888/deadlock/stats

# 获取实时监控状态
curl http://localhost:18888/deadlock/monitor/status

# 获取InnoDB状态
curl http://localhost:18888/deadlock/monitor/innodb-status
```

#### 🔍 死锁信息解析
`DeadlockMonitor` 类会自动解析 `SHOW ENGINE INNODB STATUS` 的输出，提取：
- 死锁发生时间
- 涉及的事务信息
- 等待和持有的锁
- 被回滚的事务
- SQL语句
- 分析建议

### 5.2 死锁监控切面

`@MonitorDeadlock` 注解会自动监控方法执行过程中的死锁异常：

```java
@MonitorDeadlock(value = "转账操作", autoRetry = true, maxRetries = 3)
public void transferMoney() {
    // 业务逻辑
}
```

功能特性：
- 自动捕获死锁异常
- 支持自动重试
- 生成详细的死锁报告
- 记录死锁统计信息

### 5.3 MySQL死锁检测命令

```sql
-- 查看InnoDB状态 (包含最近一次死锁信息)
SHOW ENGINE INNODB STATUS;

-- 查看当前锁等待情况
SELECT * FROM information_schema.innodb_lock_waits;

-- 查看当前事务状态
SELECT * FROM information_schema.innodb_trx;

-- 查看当前锁信息
SELECT * FROM performance_schema.data_locks;
```

---

## 6. 死锁解决方案

### 6.1 预防死锁策略

#### 🔒 1. 统一加锁顺序
```java
// ❌ 错误示例: 随意的加锁顺序
lockAccount(accountA);
lockAccount(accountB);

// ✅ 正确示例: 按账户号排序加锁
List<String> accounts = Arrays.asList(accountA, accountB);
Collections.sort(accounts);
for (String account : accounts) {
    lockAccount(account);
}
```

#### ⏱️ 2. 缩短事务时间
```java
// ❌ 错误示例: 长时间持有锁
@Transactional
public void badExample() {
    Account account = accountMapper.selectForUpdate(accountNo);
    // 长时间的业务处理...
    complexBusinessLogic(); // 持有锁时间过长
    updateAccount(account);
}

// ✅ 正确示例: 减少锁持有时间
@Transactional
public void goodExample() {
    // 先进行不需要锁的处理
    ComplexResult result = complexBusinessLogic();
    
    // 最后才获取锁并快速更新
    Account account = accountMapper.selectForUpdate(accountNo);
    updateAccountWithResult(account, result);
}
```

#### 🎯 3. 降低锁粒度
```java
// ❌ 错误示例: 大范围加锁
SELECT * FROM orders WHERE create_time > '2024-01-01' FOR UPDATE;

// ✅ 正确示例: 精确锁定
SELECT * FROM orders WHERE id = 12345 FOR UPDATE;
```

### 6.2 死锁检测和恢复

#### 🔄 1. 自动重试机制
```java
@Retry(maxAttempts = 3, delay = 100)
@Transactional
public void transferWithRetry() {
    // 业务逻辑，出现死锁时自动重试
}
```

#### 📊 2. 死锁统计和告警
```java
// 监控死锁频率
if (deadlockCount > threshold) {
    alertSystem.sendDeadlockAlert();
}
```

### 6.3 具体场景解决方案

#### 💰 转账场景
1. **按账户号排序加锁**: 避免AB-BA死锁
2. **使用乐观锁**: 避免长时间持有行锁
3. **业务层去重**: 防止重复转账请求

#### 📦 库存场景
1. **批量按ID排序加锁**: 一次性获取所有需要的锁
2. **预留-确认模式**: 两阶段提交减少锁冲突
3. **库存预扣设计**: 异步处理库存扣减

#### 📇 索引场景
1. **降低隔离级别**: 使用READ_COMMITTED减少Gap锁
2. **避免范围查询**: 使用精确的主键查询
3. **唯一索引设计**: 利用唯一约束避免重复插入

---

## 7. 性能优化建议

### 7.1 数据库层面优化

#### 📊 索引优化
```sql
-- 为经常查询的列添加索引
ALTER TABLE account ADD INDEX idx_account_no (account_no);
ALTER TABLE inventory ADD INDEX idx_product_id (product_id);
ALTER TABLE order_locks ADD INDEX idx_user_status (user_id, status);
```

#### ⚙️ 事务隔离级别调整
```sql
-- 如果业务允许，降低隔离级别减少锁冲突
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 🔧 InnoDB参数调优
```sql
-- 调整锁等待超时时间
SET GLOBAL innodb_lock_wait_timeout = 10;

-- 启用死锁检测
SET GLOBAL innodb_deadlock_detect = ON;
```

### 7.2 应用层面优化

#### 🚀 连接池配置
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 300000
```

#### 🔄 业务逻辑优化
1. **批量操作**: 减少数据库交互次数
2. **异步处理**: 非核心逻辑异步执行
3. **缓存应用**: 减少数据库查询压力

### 7.3 监控和告警

#### 📈 关键指标监控
- 死锁发生频率
- 平均锁等待时间
- 事务回滚率
- 数据库连接池使用率

#### 🚨 告警策略
```java
// 示例告警条件
if (deadlockRate > 0.1%) {  // 死锁率超过0.1%
    sendAlert("Database deadlock rate is too high");
}

if (avgLockWaitTime > 1000) {  // 平均等锁时间超过1秒
    sendAlert("Database lock wait time is too long");
}
```

---

## 8. 常见问题解答

### Q1: 为什么我的死锁测试没有产生死锁？

**A**: 可能的原因：
1. **时机问题**: 两个事务没有同时执行，试着减少sleep时间或增加并发量
2. **隔离级别**: 如果使用READ_COMMITTED，可能不会产生Gap锁
3. **数据问题**: 测试数据不存在或已经被锁定

```java
// 增加并发和减少等待时间
for (int i = 0; i < 100; i++) {
    CompletableFuture.runAsync(() -> testDeadlock());
}
```

### Q2: 如何模拟生产环境的死锁场景？

**A**: 建议方法：
1. **使用真实的业务数据量**: 插入足够多的测试数据
2. **模拟真实的并发压力**: 使用多线程并发测试
3. **使用生产环境相同的配置**: 相同的隔离级别和参数

### Q3: 死锁发生后如何快速定位问题？

**A**: 诊断步骤：
1. **查看InnoDB状态**: `SHOW ENGINE INNODB STATUS`
2. **分析死锁日志**: 查看最近一次死锁的详细信息
3. **检查应用日志**: 查看死锁发生时的业务操作
4. **分析SQL执行计划**: 确认锁定的索引和范围

### Q4: 生产环境如何预防死锁？

**A**: 最佳实践：
1. **代码审查**: 重点检查事务边界和加锁顺序
2. **压力测试**: 在类生产环境进行充分的并发测试
3. **监控告警**: 部署死锁监控和告警系统
4. **定期分析**: 定期分析数据库性能报告

### Q5: 出现死锁后应该如何处理？

**A**: 处理策略：
1. **自动重试**: 对于可重试的操作，实现自动重试机制
2. **业务降级**: 必要时进行业务功能降级
3. **错误日志**: 记录详细的错误信息用于后续分析
4. **用户提示**: 给用户友好的错误提示

---

## 🎯 实战练习建议

### 初级练习
1. 运行所有提供的死锁场景，观察日志输出
2. 修改并发线程数，观察死锁发生频率的变化
3. 尝试不同的事务隔离级别，观察死锁行为差异

### 中级练习
1. 实现自己的业务场景死锁测试
2. 优化现有的死锁解决方案
3. 实现更复杂的死锁监控功能

### 高级练习
1. 设计分布式环境下的死锁检测机制
2. 实现基于机器学习的死锁预测
3. 优化数据库设计，从根本上减少死锁可能性

---

## 📚 参考资料

1. [MySQL官方文档 - InnoDB锁和事务模型](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html)
2. [高性能MySQL第3版](https://book.douban.com/subject/23008813/)
3. [MySQL实战45讲](https://time.geekbang.org/column/intro/139)
4. [数据库事务处理的艺术](https://book.douban.com/subject/10433752/)

---

## 💡 总结

通过本实战项目，你应该掌握：

1. **理论基础**: 深入理解数据库死锁的产生原理和类型
2. **实战经验**: 通过真实场景了解死锁的表现形式
3. **解决方案**: 学会多种死锁预防和解决策略
4. **监控诊断**: 掌握死锁监控和问题定位的方法
5. **最佳实践**: 了解生产环境中的死锁处理最佳实践

记住：**死锁不可怕，可怕的是不知道如何应对！** 通过系统的学习和实践，你一定能够成为数据库死锁问题的解决专家！

---

## 🤝 贡献和反馈

如果你在学习过程中发现问题或有改进建议，欢迎：
- 提交Issue
- 发起Pull Request  
- 分享你的实践经验

让我们一起把这个死锁学习项目做得更好！ 🚀