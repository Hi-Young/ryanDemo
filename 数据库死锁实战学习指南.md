# 数据库死锁实战学习指南

## 📖 目录

1. [死锁基础理论](#1-死锁基础理论)
2. [项目结构说明](#2-项目结构说明)
3. [环境准备](#3-环境准备)
4. [死锁场景实战](#4-死锁场景实战)
5. [死锁监控和诊断](#5-死锁监控和诊断)
6. [死锁解决方案](#6-死锁解决方案)
7. [性能优化建议](#7-性能优化建议)
8. [常见问题解答](#8-常见问题解答)

---

## 1. 死锁基础理论

### 1.1 什么是数据库死锁

数据库死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种相互等待的现象。当存在外力介入时，这些事务都无法继续执行下去。

### 1.2 死锁产生的四个必要条件

1. **互斥条件**: 资源不能被多个事务同时使用
2. **持有和等待条件**: 事务持有至少一个资源，并等待获取其他事务持有的资源
3. **非剥夺条件**: 资源不能被强制从一个事务中抢夺
4. **循环等待条件**: 存在一个事务循环链，每个事务都在等待下一个事务所持有的资源

### 1.3 MySQL中的锁类型

#### 行级锁 (Row-level Locks)
- **Record Lock**: 记录锁，锁定索引记录
- **Gap Lock**: 间隙锁，锁定索引记录之间的间隙
- **Next-Key Lock**: Record Lock + Gap Lock

#### 事务隔离级别与锁的关系
- **READ UNCOMMITTED**: 最低级别，几乎不加锁
- **READ COMMITTED**: 只锁定正在读取的行
- **REPEATABLE READ**: MySQL默认级别，使用Gap Lock和Next-Key Lock
- **SERIALIZABLE**: 最高级别，锁定所有读取的行

---

## 2. 项目结构说明

```
src/main/java/com/ryan/deadlock/
├── entity/          # 实体类
│   ├── Account.java      # 账户实体
│   ├── Inventory.java    # 库存实体
│   └── OrderLock.java    # 订单实体
├── mapper/          # 数据访问层
│   ├── AccountMapper.java
│   ├── InventoryMapper.java
│   └── OrderLockMapper.java
├── service/         # 业务服务层
│   ├── TransferDeadlockService.java    # 转账死锁场景
│   ├── InventoryDeadlockService.java   # 库存死锁场景
│   └── IndexDeadlockService.java       # 索引死锁场景
├── monitor/         # 死锁监控
│   └── DeadlockMonitor.java
├── aspect/          # AOP切面
│   └── DeadlockMonitorAspect.java
└── controller/      # 控制器
    └── DeadlockTestController.java

src/main/resources/
└── sql/
    └── deadlock_tables.sql  # 数据库表结构
```

---

## 3. 环境准备

### 3.1 数据库初始化

1. **执行SQL脚本**
   ```bash
   mysql -u root -p < src/main/resources/sql/deadlock_tables.sql
   ```

2. **验证表创建**
   ```sql
   SHOW TABLES;
   -- 应该看到: account, inventory, order_locks
   ```

### 3.2 启动应用

```bash
# 方式1: Maven启动
mvn spring-boot:run

# 方式2: IDE启动
# 运行 com.RyanDemoApplication.main()
```

### 3.3 访问测试接口

- 主页信息: `GET http://localhost:18888/deadlock/`
- Swagger文档: `http://localhost:18888/swagger-ui.html` (如果配置了Swagger)

---

## 4. 死锁场景实战

### 4.1 转账死锁场景

#### 💰 业务场景
银行转账系统中，A向B转账的同时B向A转账，由于加锁顺序不同导致死锁。

#### 🔍 死锁原理
```
事务1: 锁定账户A → 等待锁定账户B
事务2: 锁定账户B → 等待锁定账户A
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **触发死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/transfer/simulate
   ```

2. **单独测试死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/transfer/deadlock-version?fromAccount=ACC001&toAccount=ACC002&amount=100.00"
   ```

3. **测试无死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/transfer/no-deadlock-version?fromAccount=ACC001&toAccount=ACC002&amount=100.00"
   ```

#### 📊 关键代码分析

**死锁版本 (TransferDeadlockService.transferWithDeadlock)**:
```java
// 问题: 按参数顺序加锁，容易产生死锁
Account fromAccount = accountMapper.selectByAccountNoForUpdate(fromAccountNo);
Account toAccount = accountMapper.selectByAccountNoForUpdate(toAccountNo);
```

**无死锁版本 (TransferDeadlockService.transferWithoutDeadlock)**:
```java
// 解决方案: 统一加锁顺序
String firstLockAccount = fromAccountNo.compareTo(toAccountNo) < 0 ? fromAccountNo : toAccountNo;
String secondLockAccount = fromAccountNo.compareTo(toAccountNo) < 0 ? toAccountNo : fromAccountNo;
```

### 4.2 库存扣减死锁场景

#### 📦 业务场景
电商系统中，多个订单同时扣减不同商品的库存，由于商品锁定顺序不同导致死锁。

#### 🔍 死锁原理
```
订单1: 锁定商品1001 → 等待锁定商品1002
订单2: 锁定商品1002 → 等待锁定商品1001
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **触发库存死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/inventory/simulate
   ```

2. **测试死锁版本**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/inventory/reduce-deadlock-version?productIds=1001,1002&quantities=5,3"
   ```

3. **测试预留库存模式**
   ```bash
   curl -X POST "http://localhost:18888/deadlock/inventory/reserve-confirm?productIds=1001,1002&quantities=2,1"
   ```

#### 📊 关键代码分析

**死锁版本**:
```java
// 问题: 按传入顺序逐个加锁
for (Integer productId : productIds) {
    Inventory inventory = inventoryMapper.selectByProductIdForUpdate(productId);
}
```

**无死锁版本**:
```java
// 解决方案: 按商品ID升序批量加锁
List<Inventory> inventories = inventoryMapper.selectByProductIdsForUpdate(productIds);
// SQL: SELECT * FROM inventory WHERE product_id IN (...) ORDER BY product_id FOR UPDATE
```

### 4.3 索引死锁场景

#### 📇 业务场景
Gap锁和Next-Key锁在并发范围查询和插入时产生的死锁。

#### 🔍 死锁原理

**Gap锁死锁**:
```
事务1: 范围查询产生Gap锁 → 尝试插入数据等待插入意向锁
事务2: 插入数据等待Gap锁 → 尝试范围查询等待Gap锁
结果:  相互等待，产生死锁
```

**Next-Key锁死锁**:
```
事务1: SELECT ... FOR UPDATE (用户1) → 等待用户2的锁
事务2: SELECT ... FOR UPDATE (用户2) → 等待用户1的锁
结果:  循环等待，产生死锁
```

#### 🧪 测试步骤
1. **Gap锁死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/index/simulate-gap-lock
   ```

2. **简单Gap锁死锁测试** (推荐：更贴近生产环境)
   ```bash
   curl -X POST http://localhost:18888/deadlock/index/simple-gap-lock
   ```

3. **Next-Key锁死锁测试**
   ```bash
   curl -X POST http://localhost:18888/deadlock/index/simulate-next-key-lock
   ```

#### 📊 关键代码分析

**传统Gap锁场景 (使用SELECT FOR UPDATE)**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ) // 关键: 可重复读级别
public void gapLockDeadlockScenario1() {
    // 范围查询产生Gap锁
    List<OrderLock> orders = orderLockMapper.selectOrdersByTimeRange(startTime, endTime);
    
    // 在Gap范围内插入，可能死锁
    orderLockMapper.insert(newOrder);
}
```

**简单Gap锁场景 (生产环境常见)**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void insertOrderWithGapLock(Integer threadId) {
    if (threadId == 1) {
        // 线程1: 先插入user_id=10，再插入user_id=20
        orderLockMapper.insert(new OrderLock("order1", 10, ...));
        Thread.sleep(200);
        orderLockMapper.insert(new OrderLock("order2", 20, ...)); // 可能被阻塞
    } else {
        // 线程2: 先插入user_id=20，再插入user_id=10  
        orderLockMapper.insert(new OrderLock("order3", 20, ...));
        Thread.sleep(200);
        orderLockMapper.insert(new OrderLock("order4", 10, ...)); // 可能被阻塞
    }
}
```

**Gap锁死锁原理解析**:
```
阶段1: 插入不同范围的数据
线程1插入user_id=10 ✅ (获得Gap锁：9-11区间)
线程2插入user_id=20 ✅ (获得Gap锁：19-21区间)

阶段2: 交叉插入导致死锁
线程1尝试插入user_id=20 ❌ (被线程2的Gap锁阻塞)
线程2尝试插入user_id=10 ❌ (被线程1的Gap锁阻塞)

结果: 循环等待 → 死锁检测 → 回滚受害者事务
```

---

## 5. 死锁监控和诊断

### 5.1 实时死锁监控

#### 📊 监控接口
```bash
# 获取死锁统计
curl http://localhost:18888/deadlock/stats

# 获取实时监控状态
curl http://localhost:18888/deadlock/monitor/status

# 获取InnoDB状态
curl http://localhost:18888/deadlock/monitor/innodb-status
```

#### 🔍 死锁信息解析
`DeadlockMonitor` 类会自动解析 `SHOW ENGINE INNODB STATUS` 的输出，提取：
- 死锁发生时间
- 涉及的事务信息
- 等待和持有的锁
- 被回滚的事务
- SQL语句
- 分析建议

### 5.2 死锁监控切面

`@MonitorDeadlock` 注解会自动监控方法执行过程中的死锁异常：

```java
@MonitorDeadlock(value = "转账操作", autoRetry = true, maxRetries = 3)
public void transferMoney() {
    // 业务逻辑
}
```

功能特性：
- 自动捕获死锁异常
- 支持自动重试
- 生成详细的死锁报告
- 记录死锁统计信息

### 5.3 MySQL死锁检测命令

```sql
-- 查看InnoDB状态 (包含最近一次死锁信息)
SHOW ENGINE INNODB STATUS;

-- 查看当前锁等待情况
SELECT * FROM information_schema.innodb_lock_waits;

-- 查看当前事务状态
SELECT * FROM information_schema.innodb_trx;

-- 查看当前锁信息
SELECT * FROM performance_schema.data_locks;
```

---

## 6. 死锁解决方案

### 6.1 预防死锁策略

#### 🔒 1. 统一加锁顺序
```java
// ❌ 错误示例: 随意的加锁顺序
lockAccount(accountA);
lockAccount(accountB);

// ✅ 正确示例: 按账户号排序加锁
List<String> accounts = Arrays.asList(accountA, accountB);
Collections.sort(accounts);
for (String account : accounts) {
    lockAccount(account);
}
```

#### ⏱️ 2. 缩短事务时间
```java
// ❌ 错误示例: 长时间持有锁
@Transactional
public void badExample() {
    Account account = accountMapper.selectForUpdate(accountNo);
    // 长时间的业务处理...
    complexBusinessLogic(); // 持有锁时间过长
    updateAccount(account);
}

// ✅ 正确示例: 减少锁持有时间
@Transactional
public void goodExample() {
    // 先进行不需要锁的处理
    ComplexResult result = complexBusinessLogic();
    
    // 最后才获取锁并快速更新
    Account account = accountMapper.selectForUpdate(accountNo);
    updateAccountWithResult(account, result);
}
```

#### 🎯 3. 降低锁粒度
```java
// ❌ 错误示例: 大范围加锁
SELECT * FROM orders WHERE create_time > '2024-01-01' FOR UPDATE;

// ✅ 正确示例: 精确锁定
SELECT * FROM orders WHERE id = 12345 FOR UPDATE;
```

### 6.2 死锁检测和恢复

#### 🔄 1. 自动重试机制
```java
@Retry(maxAttempts = 3, delay = 100)
@Transactional
public void transferWithRetry() {
    // 业务逻辑，出现死锁时自动重试
}
```

#### 📊 2. 死锁统计和告警
```java
// 监控死锁频率
if (deadlockCount > threshold) {
    alertSystem.sendDeadlockAlert();
}
```

### 6.3 具体场景解决方案

#### 💰 转账场景
1. **按账户号排序加锁**: 避免AB-BA死锁
2. **使用乐观锁**: 避免长时间持有行锁
3. **业务层去重**: 防止重复转账请求

#### 📦 库存场景
1. **批量按ID排序加锁**: 一次性获取所有需要的锁
2. **预留-确认模式**: 两阶段提交减少锁冲突
3. **库存预扣设计**: 异步处理库存扣减

#### 📇 索引场景
1. **降低隔离级别**: 使用READ_COMMITTED减少Gap锁
   ```java
   @Transactional(isolation = Isolation.READ_COMMITTED)
   public void avoidGapLock() {
       // READ_COMMITTED级别下不会产生Gap锁
       orderLockMapper.insert(newOrder);
   }
   ```

2. **避免范围查询**: 使用精确的主键查询
   ```java
   // ❌ 容易产生Gap锁
   SELECT * FROM orders WHERE create_time BETWEEN '2024-01-01' AND '2024-12-31' FOR UPDATE;
   
   // ✅ 精确锁定，避免Gap锁
   SELECT * FROM orders WHERE id = 12345 FOR UPDATE;
   ```

3. **统一插入顺序**: 按固定顺序访问资源
   ```java
   // ✅ 统一按user_id升序插入
   List<Integer> userIds = Arrays.asList(20, 10);
   userIds.sort(Integer::compareTo); // 排序：[10, 20]
   for (Integer userId : userIds) {
       insertOrder(userId);
   }
   ```

4. **唯一索引设计**: 利用唯一约束避免重复插入

---

## 7. 性能优化建议

### 7.1 数据库层面优化

#### 📊 索引优化
```sql
-- 为经常查询的列添加索引
ALTER TABLE account ADD INDEX idx_account_no (account_no);
ALTER TABLE inventory ADD INDEX idx_product_id (product_id);
ALTER TABLE order_locks ADD INDEX idx_user_status (user_id, status);
```

#### ⚙️ 事务隔离级别调整
```sql
-- 如果业务允许，降低隔离级别减少锁冲突
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 🔧 InnoDB参数调优
```sql
-- 调整锁等待超时时间
SET GLOBAL innodb_lock_wait_timeout = 10;

-- 启用死锁检测
SET GLOBAL innodb_deadlock_detect = ON;
```

### 7.2 应用层面优化

#### 🚀 连接池配置
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 300000
```

#### 🔄 业务逻辑优化
1. **批量操作**: 减少数据库交互次数
2. **异步处理**: 非核心逻辑异步执行
3. **缓存应用**: 减少数据库查询压力

### 7.3 监控和告警

#### 📈 关键指标监控
- 死锁发生频率
- 平均锁等待时间
- 事务回滚率
- 数据库连接池使用率

#### 🚨 告警策略
```java
// 示例告警条件
if (deadlockRate > 0.1%) {  // 死锁率超过0.1%
    sendAlert("Database deadlock rate is too high");
}

if (avgLockWaitTime > 1000) {  // 平均等锁时间超过1秒
    sendAlert("Database lock wait time is too long");
}
```

---

## 8. 常见问题解答

### Q1: 为什么我的死锁测试没有产生死锁？

**A**: 可能的原因：
1. **时机问题**: 两个事务没有同时执行，试着减少sleep时间或增加并发量
2. **隔离级别**: 如果使用READ_COMMITTED，可能不会产生Gap锁
3. **数据问题**: 测试数据不存在或已经被锁定

```java
// 增加并发和减少等待时间
for (int i = 0; i < 100; i++) {
    CompletableFuture.runAsync(() -> testDeadlock());
}
```

### Q2: 如何模拟生产环境的死锁场景？

**A**: 建议方法：
1. **使用真实的业务数据量**: 插入足够多的测试数据
2. **模拟真实的并发压力**: 使用多线程并发测试
3. **使用生产环境相同的配置**: 相同的隔离级别和参数

### Q3: 死锁发生后如何快速定位问题？

**A**: 诊断步骤：
1. **查看InnoDB状态**: `SHOW ENGINE INNODB STATUS`
2. **分析死锁日志**: 查看最近一次死锁的详细信息
3. **检查应用日志**: 查看死锁发生时的业务操作
4. **分析SQL执行计划**: 确认锁定的索引和范围

### Q4: 生产环境如何预防死锁？

**A**: 最佳实践：
1. **代码审查**: 重点检查事务边界和加锁顺序
2. **压力测试**: 在类生产环境进行充分的并发测试
3. **监控告警**: 部署死锁监控和告警系统
4. **定期分析**: 定期分析数据库性能报告

### Q5: 出现死锁后应该如何处理？

**A**: 处理策略：
1. **自动重试**: 对于可重试的操作，实现自动重试机制
2. **业务降级**: 必要时进行业务功能降级
3. **错误日志**: 记录详细的错误信息用于后续分析
4. **用户提示**: 给用户友好的错误提示

### Q6: Gap锁死锁有哪些常见的解决方案？ 🔧

**A**: 主要解决策略：

#### 1️⃣ **降低隔离级别** (最简单有效)
```java
// 从REPEATABLE_READ改为READ_COMMITTED
@Transactional(isolation = Isolation.READ_COMMITTED)
public void insertOrderSafely() {
    // READ_COMMITTED下不会产生Gap锁
    orderLockMapper.insert(newOrder);
}
```

**优点**: 彻底避免Gap锁，实现简单  
**缺点**: 可能出现幻读，需要业务层处理

#### 2️⃣ **统一访问顺序** (最常用)
```java
public void insertMultipleOrdersSafely(List<OrderInfo> orders) {
    // 按user_id排序，确保加锁顺序一致
    orders.sort(Comparator.comparing(OrderInfo::getUserId));
    
    for (OrderInfo orderInfo : orders) {
        orderLockMapper.insert(createOrder(orderInfo));
    }
}
```

#### 3️⃣ **缩小锁范围** (推荐)
```java
// ❌ 大范围Gap锁
SELECT * FROM orders WHERE user_id BETWEEN 1 AND 100 FOR UPDATE;

// ✅ 精确锁定
SELECT * FROM orders WHERE user_id = ? AND order_id = ? FOR UPDATE;
```

#### 4️⃣ **重试机制** (兜底策略)
```java
@Retryable(value = DeadlockLoserDataAccessException.class, maxAttempts = 3)
@Transactional
public void insertOrderWithRetry(OrderLock order) {
    orderLockMapper.insert(order);
}
```

### Q7: 为什么@Transactional注解在多线程环境中不生效？❗ 重要教训

**A**: 这是一个极其重要的实战发现！

#### 🚨 问题现象
```java
Thread thread1 = new Thread(() -> {
    transferWithDeadlock("ACC001", "ACC002", amount); // ❌ 事务不生效！
}, "Transfer-Thread-1");
```

**事务状态检查结果**：
```
INFO[Transfer-Thread-1] 事务状态检查: 事务活跃=false, 事务名称=null
INFO[Transfer-Thread-2] 事务状态检查: 事务活跃=false, 事务名称=null
```

#### 🔍 根本原因分析

**Spring事务是基于AOP代理实现的**，当你在线程中直接调用方法时：

1. **直接方法调用绕过代理**：
   ```java
   // 这样调用绕过了Spring AOP代理
   this.transferWithDeadlock(...);  // ❌
   transferWithDeadlock(...);       // ❌
   ```

2. **没有事务边界**：
   - `SELECT ... FOR UPDATE` 获取的锁在每个SQL执行完后立即释放
   - 多个SQL操作之间没有事务连接
   - 无法形成真正的死锁场景

#### ✅ 正确解决方案

**方案1：注入自己的代理**
```java
@Service
public class TransferDeadlockService {
    
    @Autowired
    private AccountMapper accountMapper;
    
    // 注入自己的代理，确保事务生效
    @Autowired
    private TransferDeadlockService self;
    
    public void simulateDeadlock() {
        Thread thread1 = new Thread(() -> {
            // ✅ 通过代理调用，事务生效
            self.transferWithDeadlock("ACC001", "ACC002", amount);
        });
    }
    
    @Transactional
    public void transferWithDeadlock(String from, String to, BigDecimal amount) {
        // 事务方法实现
    }
}
```

**方案2：使用编程式事务**
```java
@Autowired
private PlatformTransactionManager transactionManager;

Thread thread1 = new Thread(() -> {
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.execute(status -> {
        transferWithDeadlock("ACC001", "ACC002", amount);
        return null;
    });
});
```

#### 📊 效果对比

**修复前（事务不生效）**：
```
INFO[Transfer-Thread-1] 事务状态检查: 事务活跃=false, 事务名称=null
INFO[Transfer-Thread-2] 事务状态检查: 事务活跃=false, 事务名称=null
INFO两个线程都已完成执行  # 没有死锁发生
```

**修复后（事务生效）**：
```
INFO[Transfer-Thread-1] 事务状态检查: 事务活跃=true, 事务名称=com.ryan...
INFO[Transfer-Thread-2] 事务状态检查: 事务活跃=true, 事务名称=com.ryan...
ERROR Deadlock found when trying to get lock; try restarting transaction  # 🎉 成功产生死锁！
```

#### 🎯 关键要点总结

1. **Spring AOP原理**：`@Transactional`只在通过Spring代理调用时生效
2. **多线程陷阱**：新线程中直接调用方法会绕过代理
3. **调试技巧**：使用`TransactionSynchronizationManager`检查事务状态
4. **解决方案**：注入自己或使用编程式事务
5. **实战价值**：这个发现对理解Spring事务机制至关重要

#### ⚠️ 生产环境警告

这个问题在生产环境中可能导致：
- 数据一致性问题
- 锁机制失效
- 并发控制失败
- 业务逻辑错误

**务必确保多线程环境中的事务调用方式正确！**

### Q8: 生产环境中Gap锁死锁的实际案例和处理经验？ 💼

**A**: 常见的生产案例和处理方法：

#### 📋 **案例1: 电商订单并发创建**
**场景**: 多个用户同时下单，按用户ID范围插入订单  
**死锁原因**: 不同线程交叉插入不同用户范围的订单  
**解决方案**: 
```java
// 按用户ID排序后批量插入
public void createOrdersBatch(List<CreateOrderRequest> requests) {
    requests.sort(Comparator.comparing(CreateOrderRequest::getUserId));
    // 按排序后的顺序逐个处理
}
```

#### 📋 **案例2: 库存系统并发扣减**  
**场景**: 多个订单同时扣减不同商品库存  
**死锁原因**: 订单1锁商品A再锁商品B，订单2锁商品B再锁商品A  
**解决方案**:
```java
// 统一按商品ID升序加锁
List<Integer> productIds = Arrays.asList(productB, productA);
productIds.sort(Integer::compareTo);
for (Integer productId : productIds) {
    lockAndReduceStock(productId);
}
```

#### 📋 **案例3: 分表场景下的Gap锁死锁**
**场景**: 按时间分表，并发插入相邻时间段数据  
**解决方案**: 改用READ_COMMITTED + 应用层幻读控制

#### 🎯 **生产环境最佳实践**
1. **监控告警**: 死锁率 > 0.1% 立即告警
2. **自动重试**: 3次重试 + 指数退避
3. **降级策略**: 死锁频发时暂时串行化处理
4. **定期分析**: 每周分析死锁日志，优化热点代码

---

## 🎯 实战练习建议

### 初级练习
1. 运行所有提供的死锁场景，观察日志输出
2. 修改并发线程数，观察死锁发生频率的变化
3. 尝试不同的事务隔离级别，观察死锁行为差异

### 中级练习
1. 实现自己的业务场景死锁测试
2. 优化现有的死锁解决方案  
3. 对比不同隔离级别下的Gap锁行为
4. 实现基于INSERT的简单Gap锁死锁场景
5. 实现更复杂的死锁监控功能

### 高级练习
1. 设计分布式环境下的死锁检测机制
2. 实现基于机器学习的死锁预测
3. 优化数据库设计，从根本上减少死锁可能性

---

## 📚 参考资料

1. [MySQL官方文档 - InnoDB锁和事务模型](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html)
2. [高性能MySQL第3版](https://book.douban.com/subject/23008813/)
3. [MySQL实战45讲](https://time.geekbang.org/column/intro/139)
4. [数据库事务处理的艺术](https://book.douban.com/subject/10433752/)

---

## 💡 总结

通过本实战项目，你应该掌握：

1. **理论基础**: 深入理解数据库死锁的产生原理和类型
2. **实战经验**: 通过真实场景了解死锁的表现形式
3. **解决方案**: 学会多种死锁预防和解决策略
4. **监控诊断**: 掌握死锁监控和问题定位的方法
5. **最佳实践**: 了解生产环境中的死锁处理最佳实践

记住：**死锁不可怕，可怕的是不知道如何应对！** 通过系统的学习和实践，你一定能够成为数据库死锁问题的解决专家！

---

## 🤝 贡献和反馈

如果你在学习过程中发现问题或有改进建议，欢迎：
- 提交Issue
- 发起Pull Request  
- 分享你的实践经验

让我们一起把这个死锁学习项目做得更好！ 🚀